// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: blink.proto

#ifndef PROTOBUF_blink_2eproto__INCLUDED
#define PROTOBUF_blink_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace blink {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_blink_2eproto();
void protobuf_AssignDesc_blink_2eproto();
void protobuf_ShutdownFile_blink_2eproto();

class MsgHead;
class SwooleHttp;
class SwooleHead;
class TracePoint;
class UserContext;
class MsgBody;
class MonitorDataInner;
class ReqAddMonitorLog;

enum MsgRetCode {
  EN_MSG_RET_SUCC = 0,
  EN_MSG_RET_PARSE_ERR = -1,
  EN_MSG_RET_TIMEOUT = -2,
  EN_MSG_RET_SYSTEM_ERR = -3,
  EN_MSG_RET_SKEY_INVALID = -4,
  EN_MSG_RET_MISS_HAND = -5,
  EN_MSG_RET_NOT_LOGIN = -6,
  EN_MSG_RET_GET_LOCK_FAIL = -7,
  EN_MSG_RET_CALL_REDIS_FAIL = -8,
  EN_MSG_ERT_METHOD_LIMIT = -9,
  EN_MSG_RET_SYSTEM_BUSY = -99999,
  EN_MSG_RET_DEP_SERVICE_DOWN = -100000
};
bool MsgRetCode_IsValid(int value);
const MsgRetCode MsgRetCode_MIN = EN_MSG_RET_DEP_SERVICE_DOWN;
const MsgRetCode MsgRetCode_MAX = EN_MSG_RET_SUCC;
const int MsgRetCode_ARRAYSIZE = MsgRetCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* MsgRetCode_descriptor();
inline const ::std::string& MsgRetCode_Name(MsgRetCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgRetCode_descriptor(), value);
}
inline bool MsgRetCode_Parse(
    const ::std::string& name, MsgRetCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgRetCode>(
    MsgRetCode_descriptor(), name, value);
}
enum SCallType {
  EN_MSG_TYPE_REQUEST = 1,
  EN_MSG_TYPE_RESPONSE = 2
};
bool SCallType_IsValid(int value);
const SCallType SCallType_MIN = EN_MSG_TYPE_REQUEST;
const SCallType SCallType_MAX = EN_MSG_TYPE_RESPONSE;
const int SCallType_ARRAYSIZE = SCallType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SCallType_descriptor();
inline const ::std::string& SCallType_Name(SCallType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SCallType_descriptor(), value);
}
inline bool SCallType_Parse(
    const ::std::string& name, SCallType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SCallType>(
    SCallType_descriptor(), name, value);
}
// ===================================================================

class MsgHead : public ::google::protobuf::Message {
 public:
  MsgHead();
  virtual ~MsgHead();

  MsgHead(const MsgHead& from);

  inline MsgHead& operator=(const MsgHead& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgHead& default_instance();

  void Swap(MsgHead* other);

  // implements Message ----------------------------------------------

  MsgHead* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgHead& from);
  void MergeFrom(const MsgHead& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 len = 1;
  inline bool has_len() const;
  inline void clear_len();
  static const int kLenFieldNumber = 1;
  inline ::google::protobuf::uint32 len() const;
  inline void set_len(::google::protobuf::uint32 value);

  // required fixed32 crc = 2;
  inline bool has_crc() const;
  inline void clear_crc();
  static const int kCrcFieldNumber = 2;
  inline ::google::protobuf::uint32 crc() const;
  inline void set_crc(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:blink.MsgHead)
 private:
  inline void set_has_len();
  inline void clear_has_len();
  inline void set_has_crc();
  inline void clear_has_crc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 len_;
  ::google::protobuf::uint32 crc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_blink_2eproto();
  friend void protobuf_AssignDesc_blink_2eproto();
  friend void protobuf_ShutdownFile_blink_2eproto();

  void InitAsDefaultInstance();
  static MsgHead* default_instance_;
};
// -------------------------------------------------------------------

class SwooleHttp : public ::google::protobuf::Message {
 public:
  SwooleHttp();
  virtual ~SwooleHttp();

  SwooleHttp(const SwooleHttp& from);

  inline SwooleHttp& operator=(const SwooleHttp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SwooleHttp& default_instance();

  void Swap(SwooleHttp* other);

  // implements Message ----------------------------------------------

  SwooleHttp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SwooleHttp& from);
  void MergeFrom(const SwooleHttp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .blink.SwooleHead header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::blink::SwooleHead& header() const;
  inline ::blink::SwooleHead* mutable_header();
  inline ::blink::SwooleHead* release_header();
  inline void set_allocated_header(::blink::SwooleHead* header);

  // @@protoc_insertion_point(class_scope:blink.SwooleHttp)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::blink::SwooleHead* header_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_blink_2eproto();
  friend void protobuf_AssignDesc_blink_2eproto();
  friend void protobuf_ShutdownFile_blink_2eproto();

  void InitAsDefaultInstance();
  static SwooleHttp* default_instance_;
};
// -------------------------------------------------------------------

class SwooleHead : public ::google::protobuf::Message {
 public:
  SwooleHead();
  virtual ~SwooleHead();

  SwooleHead(const SwooleHead& from);

  inline SwooleHead& operator=(const SwooleHead& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SwooleHead& default_instance();

  void Swap(SwooleHead* other);

  // implements Message ----------------------------------------------

  SwooleHead* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SwooleHead& from);
  void MergeFrom(const SwooleHead& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Host = 1;
  inline bool has_host() const;
  inline void clear_host();
  static const int kHostFieldNumber = 1;
  inline const ::std::string& host() const;
  inline void set_host(const ::std::string& value);
  inline void set_host(const char* value);
  inline void set_host(const char* value, size_t size);
  inline ::std::string* mutable_host();
  inline ::std::string* release_host();
  inline void set_allocated_host(::std::string* host);

  // @@protoc_insertion_point(class_scope:blink.SwooleHead)
 private:
  inline void set_has_host();
  inline void clear_has_host();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* host_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_blink_2eproto();
  friend void protobuf_AssignDesc_blink_2eproto();
  friend void protobuf_ShutdownFile_blink_2eproto();

  void InitAsDefaultInstance();
  static SwooleHead* default_instance_;
};
// -------------------------------------------------------------------

class TracePoint : public ::google::protobuf::Message {
 public:
  TracePoint();
  virtual ~TracePoint();

  TracePoint(const TracePoint& from);

  inline TracePoint& operator=(const TracePoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TracePoint& default_instance();

  void Swap(TracePoint* other);

  // implements Message ----------------------------------------------

  TracePoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TracePoint& from);
  void MergeFrom(const TracePoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);

  // optional string service = 2;
  inline bool has_service() const;
  inline void clear_service();
  static const int kServiceFieldNumber = 2;
  inline const ::std::string& service() const;
  inline void set_service(const ::std::string& value);
  inline void set_service(const char* value);
  inline void set_service(const char* value, size_t size);
  inline ::std::string* mutable_service();
  inline ::std::string* release_service();
  inline void set_allocated_service(::std::string* service);

  // optional string method = 3;
  inline bool has_method() const;
  inline void clear_method();
  static const int kMethodFieldNumber = 3;
  inline const ::std::string& method() const;
  inline void set_method(const ::std::string& value);
  inline void set_method(const char* value);
  inline void set_method(const char* value, size_t size);
  inline ::std::string* mutable_method();
  inline ::std::string* release_method();
  inline void set_allocated_method(::std::string* method);

  // optional string content = 4;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 4;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // optional int32 milli_cost = 5;
  inline bool has_milli_cost() const;
  inline void clear_milli_cost();
  static const int kMilliCostFieldNumber = 5;
  inline ::google::protobuf::int32 milli_cost() const;
  inline void set_milli_cost(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:blink.TracePoint)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_service();
  inline void clear_has_service();
  inline void set_has_method();
  inline void clear_has_method();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_milli_cost();
  inline void clear_has_milli_cost();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 timestamp_;
  ::std::string* service_;
  ::std::string* method_;
  ::std::string* content_;
  ::google::protobuf::int32 milli_cost_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_blink_2eproto();
  friend void protobuf_AssignDesc_blink_2eproto();
  friend void protobuf_ShutdownFile_blink_2eproto();

  void InitAsDefaultInstance();
  static TracePoint* default_instance_;
};
// -------------------------------------------------------------------

class UserContext : public ::google::protobuf::Message {
 public:
  UserContext();
  virtual ~UserContext();

  UserContext(const UserContext& from);

  inline UserContext& operator=(const UserContext& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserContext& default_instance();

  void Swap(UserContext* other);

  // implements Message ----------------------------------------------

  UserContext* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserContext& from);
  void MergeFrom(const UserContext& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // required string cli_ip = 2;
  inline bool has_cli_ip() const;
  inline void clear_cli_ip();
  static const int kCliIpFieldNumber = 2;
  inline const ::std::string& cli_ip() const;
  inline void set_cli_ip(const ::std::string& value);
  inline void set_cli_ip(const char* value);
  inline void set_cli_ip(const char* value, size_t size);
  inline ::std::string* mutable_cli_ip();
  inline ::std::string* release_cli_ip();
  inline void set_allocated_cli_ip(::std::string* cli_ip);

  // required string conn_ip = 3;
  inline bool has_conn_ip() const;
  inline void clear_conn_ip();
  static const int kConnIpFieldNumber = 3;
  inline const ::std::string& conn_ip() const;
  inline void set_conn_ip(const ::std::string& value);
  inline void set_conn_ip(const char* value);
  inline void set_conn_ip(const char* value, size_t size);
  inline ::std::string* mutable_conn_ip();
  inline ::std::string* release_conn_ip();
  inline void set_allocated_conn_ip(::std::string* conn_ip);

  // required int32 conn_port = 4;
  inline bool has_conn_port() const;
  inline void clear_conn_port();
  static const int kConnPortFieldNumber = 4;
  inline ::google::protobuf::int32 conn_port() const;
  inline void set_conn_port(::google::protobuf::int32 value);

  // optional int32 dev_type = 5;
  inline bool has_dev_type() const;
  inline void clear_dev_type();
  static const int kDevTypeFieldNumber = 5;
  inline ::google::protobuf::int32 dev_type() const;
  inline void set_dev_type(::google::protobuf::int32 value);

  // optional uint64 ss_trace_id = 6 [default = 0];
  inline bool has_ss_trace_id() const;
  inline void clear_ss_trace_id();
  static const int kSsTraceIdFieldNumber = 6;
  inline ::google::protobuf::uint64 ss_trace_id() const;
  inline void set_ss_trace_id(::google::protobuf::uint64 value);

  // optional int32 dev_crc32 = 7;
  inline bool has_dev_crc32() const;
  inline void clear_dev_crc32();
  static const int kDevCrc32FieldNumber = 7;
  inline ::google::protobuf::int32 dev_crc32() const;
  inline void set_dev_crc32(::google::protobuf::int32 value);

  // repeated .blink.TracePoint trace_points = 8;
  inline int trace_points_size() const;
  inline void clear_trace_points();
  static const int kTracePointsFieldNumber = 8;
  inline const ::blink::TracePoint& trace_points(int index) const;
  inline ::blink::TracePoint* mutable_trace_points(int index);
  inline ::blink::TracePoint* add_trace_points();
  inline const ::google::protobuf::RepeatedPtrField< ::blink::TracePoint >&
      trace_points() const;
  inline ::google::protobuf::RepeatedPtrField< ::blink::TracePoint >*
      mutable_trace_points();

  // optional string ss_trace_id_s = 9;
  inline bool has_ss_trace_id_s() const;
  inline void clear_ss_trace_id_s();
  static const int kSsTraceIdSFieldNumber = 9;
  inline const ::std::string& ss_trace_id_s() const;
  inline void set_ss_trace_id_s(const ::std::string& value);
  inline void set_ss_trace_id_s(const char* value);
  inline void set_ss_trace_id_s(const char* value, size_t size);
  inline ::std::string* mutable_ss_trace_id_s();
  inline ::std::string* release_ss_trace_id_s();
  inline void set_allocated_ss_trace_id_s(::std::string* ss_trace_id_s);

  // optional int32 flag_test = 10 [default = 0];
  inline bool has_flag_test() const;
  inline void clear_flag_test();
  static const int kFlagTestFieldNumber = 10;
  inline ::google::protobuf::int32 flag_test() const;
  inline void set_flag_test(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:blink.UserContext)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_cli_ip();
  inline void clear_has_cli_ip();
  inline void set_has_conn_ip();
  inline void clear_has_conn_ip();
  inline void set_has_conn_port();
  inline void clear_has_conn_port();
  inline void set_has_dev_type();
  inline void clear_has_dev_type();
  inline void set_has_ss_trace_id();
  inline void clear_has_ss_trace_id();
  inline void set_has_dev_crc32();
  inline void clear_has_dev_crc32();
  inline void set_has_ss_trace_id_s();
  inline void clear_has_ss_trace_id_s();
  inline void set_has_flag_test();
  inline void clear_has_flag_test();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 uid_;
  ::std::string* cli_ip_;
  ::std::string* conn_ip_;
  ::google::protobuf::int32 conn_port_;
  ::google::protobuf::int32 dev_type_;
  ::google::protobuf::uint64 ss_trace_id_;
  ::google::protobuf::RepeatedPtrField< ::blink::TracePoint > trace_points_;
  ::google::protobuf::int32 dev_crc32_;
  ::google::protobuf::int32 flag_test_;
  ::std::string* ss_trace_id_s_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_blink_2eproto();
  friend void protobuf_AssignDesc_blink_2eproto();
  friend void protobuf_ShutdownFile_blink_2eproto();

  void InitAsDefaultInstance();
  static UserContext* default_instance_;
};
// -------------------------------------------------------------------

class MsgBody : public ::google::protobuf::Message {
 public:
  MsgBody();
  virtual ~MsgBody();

  MsgBody(const MsgBody& from);

  inline MsgBody& operator=(const MsgBody& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgBody& default_instance();

  void Swap(MsgBody* other);

  // implements Message ----------------------------------------------

  MsgBody* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgBody& from);
  void MergeFrom(const MsgBody& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::google::protobuf::int32 cmd() const;
  inline void set_cmd(::google::protobuf::int32 value);

  // optional uint64 cli_req_id = 2;
  inline bool has_cli_req_id() const;
  inline void clear_cli_req_id();
  static const int kCliReqIdFieldNumber = 2;
  inline ::google::protobuf::uint64 cli_req_id() const;
  inline void set_cli_req_id(::google::protobuf::uint64 value);

  // optional int32 call_type = 3;
  inline bool has_call_type() const;
  inline void clear_call_type();
  static const int kCallTypeFieldNumber = 3;
  inline ::google::protobuf::int32 call_type() const;
  inline void set_call_type(::google::protobuf::int32 value);

  // optional uint64 session_code = 4;
  inline bool has_session_code() const;
  inline void clear_session_code();
  static const int kSessionCodeFieldNumber = 4;
  inline ::google::protobuf::uint64 session_code() const;
  inline void set_session_code(::google::protobuf::uint64 value);

  // optional .blink.UserContext uctx = 5;
  inline bool has_uctx() const;
  inline void clear_uctx();
  static const int kUctxFieldNumber = 5;
  inline const ::blink::UserContext& uctx() const;
  inline ::blink::UserContext* mutable_uctx();
  inline ::blink::UserContext* release_uctx();
  inline void set_allocated_uctx(::blink::UserContext* uctx);

  // optional uint64 ss_req_id = 6;
  inline bool has_ss_req_id() const;
  inline void clear_ss_req_id();
  static const int kSsReqIdFieldNumber = 6;
  inline ::google::protobuf::uint64 ss_req_id() const;
  inline void set_ss_req_id(::google::protobuf::uint64 value);

  // optional string service = 7;
  inline bool has_service() const;
  inline void clear_service();
  static const int kServiceFieldNumber = 7;
  inline const ::std::string& service() const;
  inline void set_service(const ::std::string& value);
  inline void set_service(const char* value);
  inline void set_service(const char* value, size_t size);
  inline ::std::string* mutable_service();
  inline ::std::string* release_service();
  inline void set_allocated_service(::std::string* service);

  // optional int32 method = 8;
  inline bool has_method() const;
  inline void clear_method();
  static const int kMethodFieldNumber = 8;
  inline ::google::protobuf::int32 method() const;
  inline void set_method(::google::protobuf::int32 value);

  // optional int32 err_code = 9;
  inline bool has_err_code() const;
  inline void clear_err_code();
  static const int kErrCodeFieldNumber = 9;
  inline ::google::protobuf::int32 err_code() const;
  inline void set_err_code(::google::protobuf::int32 value);

  // optional bytes payload = 10;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 10;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  inline ::std::string* release_payload();
  inline void set_allocated_payload(::std::string* payload);

  // optional string err_msg = 11;
  inline bool has_err_msg() const;
  inline void clear_err_msg();
  static const int kErrMsgFieldNumber = 11;
  inline const ::std::string& err_msg() const;
  inline void set_err_msg(const ::std::string& value);
  inline void set_err_msg(const char* value);
  inline void set_err_msg(const char* value, size_t size);
  inline ::std::string* mutable_err_msg();
  inline ::std::string* release_err_msg();
  inline void set_allocated_err_msg(::std::string* err_msg);

  // optional int32 need_trace_point = 12 [default = 0];
  inline bool has_need_trace_point() const;
  inline void clear_need_trace_point();
  static const int kNeedTracePointFieldNumber = 12;
  inline ::google::protobuf::int32 need_trace_point() const;
  inline void set_need_trace_point(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:blink.MsgBody)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_cli_req_id();
  inline void clear_has_cli_req_id();
  inline void set_has_call_type();
  inline void clear_has_call_type();
  inline void set_has_session_code();
  inline void clear_has_session_code();
  inline void set_has_uctx();
  inline void clear_has_uctx();
  inline void set_has_ss_req_id();
  inline void clear_has_ss_req_id();
  inline void set_has_service();
  inline void clear_has_service();
  inline void set_has_method();
  inline void clear_has_method();
  inline void set_has_err_code();
  inline void clear_has_err_code();
  inline void set_has_payload();
  inline void clear_has_payload();
  inline void set_has_err_msg();
  inline void clear_has_err_msg();
  inline void set_has_need_trace_point();
  inline void clear_has_need_trace_point();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 cli_req_id_;
  ::google::protobuf::int32 cmd_;
  ::google::protobuf::int32 call_type_;
  ::google::protobuf::uint64 session_code_;
  ::blink::UserContext* uctx_;
  ::google::protobuf::uint64 ss_req_id_;
  ::std::string* service_;
  ::google::protobuf::int32 method_;
  ::google::protobuf::int32 err_code_;
  ::std::string* payload_;
  ::std::string* err_msg_;
  ::google::protobuf::int32 need_trace_point_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_blink_2eproto();
  friend void protobuf_AssignDesc_blink_2eproto();
  friend void protobuf_ShutdownFile_blink_2eproto();

  void InitAsDefaultInstance();
  static MsgBody* default_instance_;
};
// -------------------------------------------------------------------

class MonitorDataInner : public ::google::protobuf::Message {
 public:
  MonitorDataInner();
  virtual ~MonitorDataInner();

  MonitorDataInner(const MonitorDataInner& from);

  inline MonitorDataInner& operator=(const MonitorDataInner& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MonitorDataInner& default_instance();

  void Swap(MonitorDataInner* other);

  // implements Message ----------------------------------------------

  MonitorDataInner* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MonitorDataInner& from);
  void MergeFrom(const MonitorDataInner& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string service_type = 1;
  inline bool has_service_type() const;
  inline void clear_service_type();
  static const int kServiceTypeFieldNumber = 1;
  inline const ::std::string& service_type() const;
  inline void set_service_type(const ::std::string& value);
  inline void set_service_type(const char* value);
  inline void set_service_type(const char* value, size_t size);
  inline ::std::string* mutable_service_type();
  inline ::std::string* release_service_type();
  inline void set_allocated_service_type(::std::string* service_type);

  // required string monitor_key = 2;
  inline bool has_monitor_key() const;
  inline void clear_monitor_key();
  static const int kMonitorKeyFieldNumber = 2;
  inline const ::std::string& monitor_key() const;
  inline void set_monitor_key(const ::std::string& value);
  inline void set_monitor_key(const char* value);
  inline void set_monitor_key(const char* value, size_t size);
  inline ::std::string* mutable_monitor_key();
  inline ::std::string* release_monitor_key();
  inline void set_allocated_monitor_key(::std::string* monitor_key);

  // required int32 monitor_value = 3;
  inline bool has_monitor_value() const;
  inline void clear_monitor_value();
  static const int kMonitorValueFieldNumber = 3;
  inline ::google::protobuf::int32 monitor_value() const;
  inline void set_monitor_value(::google::protobuf::int32 value);

  // optional uint64 timestamp = 4;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 4;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:blink.MonitorDataInner)
 private:
  inline void set_has_service_type();
  inline void clear_has_service_type();
  inline void set_has_monitor_key();
  inline void clear_has_monitor_key();
  inline void set_has_monitor_value();
  inline void clear_has_monitor_value();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* service_type_;
  ::std::string* monitor_key_;
  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::int32 monitor_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_blink_2eproto();
  friend void protobuf_AssignDesc_blink_2eproto();
  friend void protobuf_ShutdownFile_blink_2eproto();

  void InitAsDefaultInstance();
  static MonitorDataInner* default_instance_;
};
// -------------------------------------------------------------------

class ReqAddMonitorLog : public ::google::protobuf::Message {
 public:
  ReqAddMonitorLog();
  virtual ~ReqAddMonitorLog();

  ReqAddMonitorLog(const ReqAddMonitorLog& from);

  inline ReqAddMonitorLog& operator=(const ReqAddMonitorLog& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqAddMonitorLog& default_instance();

  void Swap(ReqAddMonitorLog* other);

  // implements Message ----------------------------------------------

  ReqAddMonitorLog* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqAddMonitorLog& from);
  void MergeFrom(const ReqAddMonitorLog& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .blink.MonitorDataInner monitor_log = 1;
  inline int monitor_log_size() const;
  inline void clear_monitor_log();
  static const int kMonitorLogFieldNumber = 1;
  inline const ::blink::MonitorDataInner& monitor_log(int index) const;
  inline ::blink::MonitorDataInner* mutable_monitor_log(int index);
  inline ::blink::MonitorDataInner* add_monitor_log();
  inline const ::google::protobuf::RepeatedPtrField< ::blink::MonitorDataInner >&
      monitor_log() const;
  inline ::google::protobuf::RepeatedPtrField< ::blink::MonitorDataInner >*
      mutable_monitor_log();

  // @@protoc_insertion_point(class_scope:blink.ReqAddMonitorLog)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::blink::MonitorDataInner > monitor_log_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_blink_2eproto();
  friend void protobuf_AssignDesc_blink_2eproto();
  friend void protobuf_ShutdownFile_blink_2eproto();

  void InitAsDefaultInstance();
  static ReqAddMonitorLog* default_instance_;
};
// ===================================================================


// ===================================================================

// MsgHead

// required fixed32 len = 1;
inline bool MsgHead::has_len() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgHead::set_has_len() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgHead::clear_has_len() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgHead::clear_len() {
  len_ = 0u;
  clear_has_len();
}
inline ::google::protobuf::uint32 MsgHead::len() const {
  return len_;
}
inline void MsgHead::set_len(::google::protobuf::uint32 value) {
  set_has_len();
  len_ = value;
}

// required fixed32 crc = 2;
inline bool MsgHead::has_crc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgHead::set_has_crc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgHead::clear_has_crc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgHead::clear_crc() {
  crc_ = 0u;
  clear_has_crc();
}
inline ::google::protobuf::uint32 MsgHead::crc() const {
  return crc_;
}
inline void MsgHead::set_crc(::google::protobuf::uint32 value) {
  set_has_crc();
  crc_ = value;
}

// -------------------------------------------------------------------

// SwooleHttp

// optional .blink.SwooleHead header = 1;
inline bool SwooleHttp::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SwooleHttp::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SwooleHttp::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SwooleHttp::clear_header() {
  if (header_ != NULL) header_->::blink::SwooleHead::Clear();
  clear_has_header();
}
inline const ::blink::SwooleHead& SwooleHttp::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::blink::SwooleHead* SwooleHttp::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::blink::SwooleHead;
  return header_;
}
inline ::blink::SwooleHead* SwooleHttp::release_header() {
  clear_has_header();
  ::blink::SwooleHead* temp = header_;
  header_ = NULL;
  return temp;
}
inline void SwooleHttp::set_allocated_header(::blink::SwooleHead* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// -------------------------------------------------------------------

// SwooleHead

// optional string Host = 1;
inline bool SwooleHead::has_host() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SwooleHead::set_has_host() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SwooleHead::clear_has_host() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SwooleHead::clear_host() {
  if (host_ != &::google::protobuf::internal::kEmptyString) {
    host_->clear();
  }
  clear_has_host();
}
inline const ::std::string& SwooleHead::host() const {
  return *host_;
}
inline void SwooleHead::set_host(const ::std::string& value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void SwooleHead::set_host(const char* value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void SwooleHead::set_host(const char* value, size_t size) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SwooleHead::mutable_host() {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  return host_;
}
inline ::std::string* SwooleHead::release_host() {
  clear_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = host_;
    host_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SwooleHead::set_allocated_host(::std::string* host) {
  if (host_ != &::google::protobuf::internal::kEmptyString) {
    delete host_;
  }
  if (host) {
    set_has_host();
    host_ = host;
  } else {
    clear_has_host();
    host_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TracePoint

// optional uint64 timestamp = 1;
inline bool TracePoint::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TracePoint::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TracePoint::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TracePoint::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 TracePoint::timestamp() const {
  return timestamp_;
}
inline void TracePoint::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional string service = 2;
inline bool TracePoint::has_service() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TracePoint::set_has_service() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TracePoint::clear_has_service() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TracePoint::clear_service() {
  if (service_ != &::google::protobuf::internal::kEmptyString) {
    service_->clear();
  }
  clear_has_service();
}
inline const ::std::string& TracePoint::service() const {
  return *service_;
}
inline void TracePoint::set_service(const ::std::string& value) {
  set_has_service();
  if (service_ == &::google::protobuf::internal::kEmptyString) {
    service_ = new ::std::string;
  }
  service_->assign(value);
}
inline void TracePoint::set_service(const char* value) {
  set_has_service();
  if (service_ == &::google::protobuf::internal::kEmptyString) {
    service_ = new ::std::string;
  }
  service_->assign(value);
}
inline void TracePoint::set_service(const char* value, size_t size) {
  set_has_service();
  if (service_ == &::google::protobuf::internal::kEmptyString) {
    service_ = new ::std::string;
  }
  service_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TracePoint::mutable_service() {
  set_has_service();
  if (service_ == &::google::protobuf::internal::kEmptyString) {
    service_ = new ::std::string;
  }
  return service_;
}
inline ::std::string* TracePoint::release_service() {
  clear_has_service();
  if (service_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = service_;
    service_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TracePoint::set_allocated_service(::std::string* service) {
  if (service_ != &::google::protobuf::internal::kEmptyString) {
    delete service_;
  }
  if (service) {
    set_has_service();
    service_ = service;
  } else {
    clear_has_service();
    service_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string method = 3;
inline bool TracePoint::has_method() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TracePoint::set_has_method() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TracePoint::clear_has_method() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TracePoint::clear_method() {
  if (method_ != &::google::protobuf::internal::kEmptyString) {
    method_->clear();
  }
  clear_has_method();
}
inline const ::std::string& TracePoint::method() const {
  return *method_;
}
inline void TracePoint::set_method(const ::std::string& value) {
  set_has_method();
  if (method_ == &::google::protobuf::internal::kEmptyString) {
    method_ = new ::std::string;
  }
  method_->assign(value);
}
inline void TracePoint::set_method(const char* value) {
  set_has_method();
  if (method_ == &::google::protobuf::internal::kEmptyString) {
    method_ = new ::std::string;
  }
  method_->assign(value);
}
inline void TracePoint::set_method(const char* value, size_t size) {
  set_has_method();
  if (method_ == &::google::protobuf::internal::kEmptyString) {
    method_ = new ::std::string;
  }
  method_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TracePoint::mutable_method() {
  set_has_method();
  if (method_ == &::google::protobuf::internal::kEmptyString) {
    method_ = new ::std::string;
  }
  return method_;
}
inline ::std::string* TracePoint::release_method() {
  clear_has_method();
  if (method_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = method_;
    method_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TracePoint::set_allocated_method(::std::string* method) {
  if (method_ != &::google::protobuf::internal::kEmptyString) {
    delete method_;
  }
  if (method) {
    set_has_method();
    method_ = method;
  } else {
    clear_has_method();
    method_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string content = 4;
inline bool TracePoint::has_content() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TracePoint::set_has_content() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TracePoint::clear_has_content() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TracePoint::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& TracePoint::content() const {
  return *content_;
}
inline void TracePoint::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void TracePoint::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void TracePoint::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TracePoint::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* TracePoint::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TracePoint::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 milli_cost = 5;
inline bool TracePoint::has_milli_cost() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TracePoint::set_has_milli_cost() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TracePoint::clear_has_milli_cost() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TracePoint::clear_milli_cost() {
  milli_cost_ = 0;
  clear_has_milli_cost();
}
inline ::google::protobuf::int32 TracePoint::milli_cost() const {
  return milli_cost_;
}
inline void TracePoint::set_milli_cost(::google::protobuf::int32 value) {
  set_has_milli_cost();
  milli_cost_ = value;
}

// -------------------------------------------------------------------

// UserContext

// required uint64 uid = 1;
inline bool UserContext::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserContext::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserContext::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserContext::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 UserContext::uid() const {
  return uid_;
}
inline void UserContext::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// required string cli_ip = 2;
inline bool UserContext::has_cli_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserContext::set_has_cli_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserContext::clear_has_cli_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserContext::clear_cli_ip() {
  if (cli_ip_ != &::google::protobuf::internal::kEmptyString) {
    cli_ip_->clear();
  }
  clear_has_cli_ip();
}
inline const ::std::string& UserContext::cli_ip() const {
  return *cli_ip_;
}
inline void UserContext::set_cli_ip(const ::std::string& value) {
  set_has_cli_ip();
  if (cli_ip_ == &::google::protobuf::internal::kEmptyString) {
    cli_ip_ = new ::std::string;
  }
  cli_ip_->assign(value);
}
inline void UserContext::set_cli_ip(const char* value) {
  set_has_cli_ip();
  if (cli_ip_ == &::google::protobuf::internal::kEmptyString) {
    cli_ip_ = new ::std::string;
  }
  cli_ip_->assign(value);
}
inline void UserContext::set_cli_ip(const char* value, size_t size) {
  set_has_cli_ip();
  if (cli_ip_ == &::google::protobuf::internal::kEmptyString) {
    cli_ip_ = new ::std::string;
  }
  cli_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserContext::mutable_cli_ip() {
  set_has_cli_ip();
  if (cli_ip_ == &::google::protobuf::internal::kEmptyString) {
    cli_ip_ = new ::std::string;
  }
  return cli_ip_;
}
inline ::std::string* UserContext::release_cli_ip() {
  clear_has_cli_ip();
  if (cli_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cli_ip_;
    cli_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserContext::set_allocated_cli_ip(::std::string* cli_ip) {
  if (cli_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete cli_ip_;
  }
  if (cli_ip) {
    set_has_cli_ip();
    cli_ip_ = cli_ip;
  } else {
    clear_has_cli_ip();
    cli_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string conn_ip = 3;
inline bool UserContext::has_conn_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserContext::set_has_conn_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserContext::clear_has_conn_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserContext::clear_conn_ip() {
  if (conn_ip_ != &::google::protobuf::internal::kEmptyString) {
    conn_ip_->clear();
  }
  clear_has_conn_ip();
}
inline const ::std::string& UserContext::conn_ip() const {
  return *conn_ip_;
}
inline void UserContext::set_conn_ip(const ::std::string& value) {
  set_has_conn_ip();
  if (conn_ip_ == &::google::protobuf::internal::kEmptyString) {
    conn_ip_ = new ::std::string;
  }
  conn_ip_->assign(value);
}
inline void UserContext::set_conn_ip(const char* value) {
  set_has_conn_ip();
  if (conn_ip_ == &::google::protobuf::internal::kEmptyString) {
    conn_ip_ = new ::std::string;
  }
  conn_ip_->assign(value);
}
inline void UserContext::set_conn_ip(const char* value, size_t size) {
  set_has_conn_ip();
  if (conn_ip_ == &::google::protobuf::internal::kEmptyString) {
    conn_ip_ = new ::std::string;
  }
  conn_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserContext::mutable_conn_ip() {
  set_has_conn_ip();
  if (conn_ip_ == &::google::protobuf::internal::kEmptyString) {
    conn_ip_ = new ::std::string;
  }
  return conn_ip_;
}
inline ::std::string* UserContext::release_conn_ip() {
  clear_has_conn_ip();
  if (conn_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = conn_ip_;
    conn_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserContext::set_allocated_conn_ip(::std::string* conn_ip) {
  if (conn_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete conn_ip_;
  }
  if (conn_ip) {
    set_has_conn_ip();
    conn_ip_ = conn_ip;
  } else {
    clear_has_conn_ip();
    conn_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 conn_port = 4;
inline bool UserContext::has_conn_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserContext::set_has_conn_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserContext::clear_has_conn_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserContext::clear_conn_port() {
  conn_port_ = 0;
  clear_has_conn_port();
}
inline ::google::protobuf::int32 UserContext::conn_port() const {
  return conn_port_;
}
inline void UserContext::set_conn_port(::google::protobuf::int32 value) {
  set_has_conn_port();
  conn_port_ = value;
}

// optional int32 dev_type = 5;
inline bool UserContext::has_dev_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserContext::set_has_dev_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserContext::clear_has_dev_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserContext::clear_dev_type() {
  dev_type_ = 0;
  clear_has_dev_type();
}
inline ::google::protobuf::int32 UserContext::dev_type() const {
  return dev_type_;
}
inline void UserContext::set_dev_type(::google::protobuf::int32 value) {
  set_has_dev_type();
  dev_type_ = value;
}

// optional uint64 ss_trace_id = 6 [default = 0];
inline bool UserContext::has_ss_trace_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserContext::set_has_ss_trace_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserContext::clear_has_ss_trace_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserContext::clear_ss_trace_id() {
  ss_trace_id_ = GOOGLE_ULONGLONG(0);
  clear_has_ss_trace_id();
}
inline ::google::protobuf::uint64 UserContext::ss_trace_id() const {
  return ss_trace_id_;
}
inline void UserContext::set_ss_trace_id(::google::protobuf::uint64 value) {
  set_has_ss_trace_id();
  ss_trace_id_ = value;
}

// optional int32 dev_crc32 = 7;
inline bool UserContext::has_dev_crc32() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserContext::set_has_dev_crc32() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserContext::clear_has_dev_crc32() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserContext::clear_dev_crc32() {
  dev_crc32_ = 0;
  clear_has_dev_crc32();
}
inline ::google::protobuf::int32 UserContext::dev_crc32() const {
  return dev_crc32_;
}
inline void UserContext::set_dev_crc32(::google::protobuf::int32 value) {
  set_has_dev_crc32();
  dev_crc32_ = value;
}

// repeated .blink.TracePoint trace_points = 8;
inline int UserContext::trace_points_size() const {
  return trace_points_.size();
}
inline void UserContext::clear_trace_points() {
  trace_points_.Clear();
}
inline const ::blink::TracePoint& UserContext::trace_points(int index) const {
  return trace_points_.Get(index);
}
inline ::blink::TracePoint* UserContext::mutable_trace_points(int index) {
  return trace_points_.Mutable(index);
}
inline ::blink::TracePoint* UserContext::add_trace_points() {
  return trace_points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blink::TracePoint >&
UserContext::trace_points() const {
  return trace_points_;
}
inline ::google::protobuf::RepeatedPtrField< ::blink::TracePoint >*
UserContext::mutable_trace_points() {
  return &trace_points_;
}

// optional string ss_trace_id_s = 9;
inline bool UserContext::has_ss_trace_id_s() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserContext::set_has_ss_trace_id_s() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserContext::clear_has_ss_trace_id_s() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserContext::clear_ss_trace_id_s() {
  if (ss_trace_id_s_ != &::google::protobuf::internal::kEmptyString) {
    ss_trace_id_s_->clear();
  }
  clear_has_ss_trace_id_s();
}
inline const ::std::string& UserContext::ss_trace_id_s() const {
  return *ss_trace_id_s_;
}
inline void UserContext::set_ss_trace_id_s(const ::std::string& value) {
  set_has_ss_trace_id_s();
  if (ss_trace_id_s_ == &::google::protobuf::internal::kEmptyString) {
    ss_trace_id_s_ = new ::std::string;
  }
  ss_trace_id_s_->assign(value);
}
inline void UserContext::set_ss_trace_id_s(const char* value) {
  set_has_ss_trace_id_s();
  if (ss_trace_id_s_ == &::google::protobuf::internal::kEmptyString) {
    ss_trace_id_s_ = new ::std::string;
  }
  ss_trace_id_s_->assign(value);
}
inline void UserContext::set_ss_trace_id_s(const char* value, size_t size) {
  set_has_ss_trace_id_s();
  if (ss_trace_id_s_ == &::google::protobuf::internal::kEmptyString) {
    ss_trace_id_s_ = new ::std::string;
  }
  ss_trace_id_s_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserContext::mutable_ss_trace_id_s() {
  set_has_ss_trace_id_s();
  if (ss_trace_id_s_ == &::google::protobuf::internal::kEmptyString) {
    ss_trace_id_s_ = new ::std::string;
  }
  return ss_trace_id_s_;
}
inline ::std::string* UserContext::release_ss_trace_id_s() {
  clear_has_ss_trace_id_s();
  if (ss_trace_id_s_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ss_trace_id_s_;
    ss_trace_id_s_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserContext::set_allocated_ss_trace_id_s(::std::string* ss_trace_id_s) {
  if (ss_trace_id_s_ != &::google::protobuf::internal::kEmptyString) {
    delete ss_trace_id_s_;
  }
  if (ss_trace_id_s) {
    set_has_ss_trace_id_s();
    ss_trace_id_s_ = ss_trace_id_s;
  } else {
    clear_has_ss_trace_id_s();
    ss_trace_id_s_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 flag_test = 10 [default = 0];
inline bool UserContext::has_flag_test() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UserContext::set_has_flag_test() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UserContext::clear_has_flag_test() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UserContext::clear_flag_test() {
  flag_test_ = 0;
  clear_has_flag_test();
}
inline ::google::protobuf::int32 UserContext::flag_test() const {
  return flag_test_;
}
inline void UserContext::set_flag_test(::google::protobuf::int32 value) {
  set_has_flag_test();
  flag_test_ = value;
}

// -------------------------------------------------------------------

// MsgBody

// optional int32 cmd = 1;
inline bool MsgBody::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgBody::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgBody::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgBody::clear_cmd() {
  cmd_ = 0;
  clear_has_cmd();
}
inline ::google::protobuf::int32 MsgBody::cmd() const {
  return cmd_;
}
inline void MsgBody::set_cmd(::google::protobuf::int32 value) {
  set_has_cmd();
  cmd_ = value;
}

// optional uint64 cli_req_id = 2;
inline bool MsgBody::has_cli_req_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgBody::set_has_cli_req_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgBody::clear_has_cli_req_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgBody::clear_cli_req_id() {
  cli_req_id_ = GOOGLE_ULONGLONG(0);
  clear_has_cli_req_id();
}
inline ::google::protobuf::uint64 MsgBody::cli_req_id() const {
  return cli_req_id_;
}
inline void MsgBody::set_cli_req_id(::google::protobuf::uint64 value) {
  set_has_cli_req_id();
  cli_req_id_ = value;
}

// optional int32 call_type = 3;
inline bool MsgBody::has_call_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgBody::set_has_call_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgBody::clear_has_call_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgBody::clear_call_type() {
  call_type_ = 0;
  clear_has_call_type();
}
inline ::google::protobuf::int32 MsgBody::call_type() const {
  return call_type_;
}
inline void MsgBody::set_call_type(::google::protobuf::int32 value) {
  set_has_call_type();
  call_type_ = value;
}

// optional uint64 session_code = 4;
inline bool MsgBody::has_session_code() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgBody::set_has_session_code() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgBody::clear_has_session_code() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgBody::clear_session_code() {
  session_code_ = GOOGLE_ULONGLONG(0);
  clear_has_session_code();
}
inline ::google::protobuf::uint64 MsgBody::session_code() const {
  return session_code_;
}
inline void MsgBody::set_session_code(::google::protobuf::uint64 value) {
  set_has_session_code();
  session_code_ = value;
}

// optional .blink.UserContext uctx = 5;
inline bool MsgBody::has_uctx() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MsgBody::set_has_uctx() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MsgBody::clear_has_uctx() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MsgBody::clear_uctx() {
  if (uctx_ != NULL) uctx_->::blink::UserContext::Clear();
  clear_has_uctx();
}
inline const ::blink::UserContext& MsgBody::uctx() const {
  return uctx_ != NULL ? *uctx_ : *default_instance_->uctx_;
}
inline ::blink::UserContext* MsgBody::mutable_uctx() {
  set_has_uctx();
  if (uctx_ == NULL) uctx_ = new ::blink::UserContext;
  return uctx_;
}
inline ::blink::UserContext* MsgBody::release_uctx() {
  clear_has_uctx();
  ::blink::UserContext* temp = uctx_;
  uctx_ = NULL;
  return temp;
}
inline void MsgBody::set_allocated_uctx(::blink::UserContext* uctx) {
  delete uctx_;
  uctx_ = uctx;
  if (uctx) {
    set_has_uctx();
  } else {
    clear_has_uctx();
  }
}

// optional uint64 ss_req_id = 6;
inline bool MsgBody::has_ss_req_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MsgBody::set_has_ss_req_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MsgBody::clear_has_ss_req_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MsgBody::clear_ss_req_id() {
  ss_req_id_ = GOOGLE_ULONGLONG(0);
  clear_has_ss_req_id();
}
inline ::google::protobuf::uint64 MsgBody::ss_req_id() const {
  return ss_req_id_;
}
inline void MsgBody::set_ss_req_id(::google::protobuf::uint64 value) {
  set_has_ss_req_id();
  ss_req_id_ = value;
}

// optional string service = 7;
inline bool MsgBody::has_service() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MsgBody::set_has_service() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MsgBody::clear_has_service() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MsgBody::clear_service() {
  if (service_ != &::google::protobuf::internal::kEmptyString) {
    service_->clear();
  }
  clear_has_service();
}
inline const ::std::string& MsgBody::service() const {
  return *service_;
}
inline void MsgBody::set_service(const ::std::string& value) {
  set_has_service();
  if (service_ == &::google::protobuf::internal::kEmptyString) {
    service_ = new ::std::string;
  }
  service_->assign(value);
}
inline void MsgBody::set_service(const char* value) {
  set_has_service();
  if (service_ == &::google::protobuf::internal::kEmptyString) {
    service_ = new ::std::string;
  }
  service_->assign(value);
}
inline void MsgBody::set_service(const char* value, size_t size) {
  set_has_service();
  if (service_ == &::google::protobuf::internal::kEmptyString) {
    service_ = new ::std::string;
  }
  service_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgBody::mutable_service() {
  set_has_service();
  if (service_ == &::google::protobuf::internal::kEmptyString) {
    service_ = new ::std::string;
  }
  return service_;
}
inline ::std::string* MsgBody::release_service() {
  clear_has_service();
  if (service_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = service_;
    service_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MsgBody::set_allocated_service(::std::string* service) {
  if (service_ != &::google::protobuf::internal::kEmptyString) {
    delete service_;
  }
  if (service) {
    set_has_service();
    service_ = service;
  } else {
    clear_has_service();
    service_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 method = 8;
inline bool MsgBody::has_method() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MsgBody::set_has_method() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MsgBody::clear_has_method() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MsgBody::clear_method() {
  method_ = 0;
  clear_has_method();
}
inline ::google::protobuf::int32 MsgBody::method() const {
  return method_;
}
inline void MsgBody::set_method(::google::protobuf::int32 value) {
  set_has_method();
  method_ = value;
}

// optional int32 err_code = 9;
inline bool MsgBody::has_err_code() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MsgBody::set_has_err_code() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MsgBody::clear_has_err_code() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MsgBody::clear_err_code() {
  err_code_ = 0;
  clear_has_err_code();
}
inline ::google::protobuf::int32 MsgBody::err_code() const {
  return err_code_;
}
inline void MsgBody::set_err_code(::google::protobuf::int32 value) {
  set_has_err_code();
  err_code_ = value;
}

// optional bytes payload = 10;
inline bool MsgBody::has_payload() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MsgBody::set_has_payload() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MsgBody::clear_has_payload() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MsgBody::clear_payload() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    payload_->clear();
  }
  clear_has_payload();
}
inline const ::std::string& MsgBody::payload() const {
  return *payload_;
}
inline void MsgBody::set_payload(const ::std::string& value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void MsgBody::set_payload(const char* value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void MsgBody::set_payload(const void* value, size_t size) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgBody::mutable_payload() {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  return payload_;
}
inline ::std::string* MsgBody::release_payload() {
  clear_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = payload_;
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MsgBody::set_allocated_payload(::std::string* payload) {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    delete payload_;
  }
  if (payload) {
    set_has_payload();
    payload_ = payload;
  } else {
    clear_has_payload();
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string err_msg = 11;
inline bool MsgBody::has_err_msg() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MsgBody::set_has_err_msg() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MsgBody::clear_has_err_msg() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MsgBody::clear_err_msg() {
  if (err_msg_ != &::google::protobuf::internal::kEmptyString) {
    err_msg_->clear();
  }
  clear_has_err_msg();
}
inline const ::std::string& MsgBody::err_msg() const {
  return *err_msg_;
}
inline void MsgBody::set_err_msg(const ::std::string& value) {
  set_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    err_msg_ = new ::std::string;
  }
  err_msg_->assign(value);
}
inline void MsgBody::set_err_msg(const char* value) {
  set_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    err_msg_ = new ::std::string;
  }
  err_msg_->assign(value);
}
inline void MsgBody::set_err_msg(const char* value, size_t size) {
  set_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    err_msg_ = new ::std::string;
  }
  err_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgBody::mutable_err_msg() {
  set_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    err_msg_ = new ::std::string;
  }
  return err_msg_;
}
inline ::std::string* MsgBody::release_err_msg() {
  clear_has_err_msg();
  if (err_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = err_msg_;
    err_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MsgBody::set_allocated_err_msg(::std::string* err_msg) {
  if (err_msg_ != &::google::protobuf::internal::kEmptyString) {
    delete err_msg_;
  }
  if (err_msg) {
    set_has_err_msg();
    err_msg_ = err_msg;
  } else {
    clear_has_err_msg();
    err_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 need_trace_point = 12 [default = 0];
inline bool MsgBody::has_need_trace_point() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MsgBody::set_has_need_trace_point() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MsgBody::clear_has_need_trace_point() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MsgBody::clear_need_trace_point() {
  need_trace_point_ = 0;
  clear_has_need_trace_point();
}
inline ::google::protobuf::int32 MsgBody::need_trace_point() const {
  return need_trace_point_;
}
inline void MsgBody::set_need_trace_point(::google::protobuf::int32 value) {
  set_has_need_trace_point();
  need_trace_point_ = value;
}

// -------------------------------------------------------------------

// MonitorDataInner

// required string service_type = 1;
inline bool MonitorDataInner::has_service_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MonitorDataInner::set_has_service_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MonitorDataInner::clear_has_service_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MonitorDataInner::clear_service_type() {
  if (service_type_ != &::google::protobuf::internal::kEmptyString) {
    service_type_->clear();
  }
  clear_has_service_type();
}
inline const ::std::string& MonitorDataInner::service_type() const {
  return *service_type_;
}
inline void MonitorDataInner::set_service_type(const ::std::string& value) {
  set_has_service_type();
  if (service_type_ == &::google::protobuf::internal::kEmptyString) {
    service_type_ = new ::std::string;
  }
  service_type_->assign(value);
}
inline void MonitorDataInner::set_service_type(const char* value) {
  set_has_service_type();
  if (service_type_ == &::google::protobuf::internal::kEmptyString) {
    service_type_ = new ::std::string;
  }
  service_type_->assign(value);
}
inline void MonitorDataInner::set_service_type(const char* value, size_t size) {
  set_has_service_type();
  if (service_type_ == &::google::protobuf::internal::kEmptyString) {
    service_type_ = new ::std::string;
  }
  service_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MonitorDataInner::mutable_service_type() {
  set_has_service_type();
  if (service_type_ == &::google::protobuf::internal::kEmptyString) {
    service_type_ = new ::std::string;
  }
  return service_type_;
}
inline ::std::string* MonitorDataInner::release_service_type() {
  clear_has_service_type();
  if (service_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = service_type_;
    service_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MonitorDataInner::set_allocated_service_type(::std::string* service_type) {
  if (service_type_ != &::google::protobuf::internal::kEmptyString) {
    delete service_type_;
  }
  if (service_type) {
    set_has_service_type();
    service_type_ = service_type;
  } else {
    clear_has_service_type();
    service_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string monitor_key = 2;
inline bool MonitorDataInner::has_monitor_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MonitorDataInner::set_has_monitor_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MonitorDataInner::clear_has_monitor_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MonitorDataInner::clear_monitor_key() {
  if (monitor_key_ != &::google::protobuf::internal::kEmptyString) {
    monitor_key_->clear();
  }
  clear_has_monitor_key();
}
inline const ::std::string& MonitorDataInner::monitor_key() const {
  return *monitor_key_;
}
inline void MonitorDataInner::set_monitor_key(const ::std::string& value) {
  set_has_monitor_key();
  if (monitor_key_ == &::google::protobuf::internal::kEmptyString) {
    monitor_key_ = new ::std::string;
  }
  monitor_key_->assign(value);
}
inline void MonitorDataInner::set_monitor_key(const char* value) {
  set_has_monitor_key();
  if (monitor_key_ == &::google::protobuf::internal::kEmptyString) {
    monitor_key_ = new ::std::string;
  }
  monitor_key_->assign(value);
}
inline void MonitorDataInner::set_monitor_key(const char* value, size_t size) {
  set_has_monitor_key();
  if (monitor_key_ == &::google::protobuf::internal::kEmptyString) {
    monitor_key_ = new ::std::string;
  }
  monitor_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MonitorDataInner::mutable_monitor_key() {
  set_has_monitor_key();
  if (monitor_key_ == &::google::protobuf::internal::kEmptyString) {
    monitor_key_ = new ::std::string;
  }
  return monitor_key_;
}
inline ::std::string* MonitorDataInner::release_monitor_key() {
  clear_has_monitor_key();
  if (monitor_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = monitor_key_;
    monitor_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MonitorDataInner::set_allocated_monitor_key(::std::string* monitor_key) {
  if (monitor_key_ != &::google::protobuf::internal::kEmptyString) {
    delete monitor_key_;
  }
  if (monitor_key) {
    set_has_monitor_key();
    monitor_key_ = monitor_key;
  } else {
    clear_has_monitor_key();
    monitor_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 monitor_value = 3;
inline bool MonitorDataInner::has_monitor_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MonitorDataInner::set_has_monitor_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MonitorDataInner::clear_has_monitor_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MonitorDataInner::clear_monitor_value() {
  monitor_value_ = 0;
  clear_has_monitor_value();
}
inline ::google::protobuf::int32 MonitorDataInner::monitor_value() const {
  return monitor_value_;
}
inline void MonitorDataInner::set_monitor_value(::google::protobuf::int32 value) {
  set_has_monitor_value();
  monitor_value_ = value;
}

// optional uint64 timestamp = 4;
inline bool MonitorDataInner::has_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MonitorDataInner::set_has_timestamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MonitorDataInner::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MonitorDataInner::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 MonitorDataInner::timestamp() const {
  return timestamp_;
}
inline void MonitorDataInner::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// -------------------------------------------------------------------

// ReqAddMonitorLog

// repeated .blink.MonitorDataInner monitor_log = 1;
inline int ReqAddMonitorLog::monitor_log_size() const {
  return monitor_log_.size();
}
inline void ReqAddMonitorLog::clear_monitor_log() {
  monitor_log_.Clear();
}
inline const ::blink::MonitorDataInner& ReqAddMonitorLog::monitor_log(int index) const {
  return monitor_log_.Get(index);
}
inline ::blink::MonitorDataInner* ReqAddMonitorLog::mutable_monitor_log(int index) {
  return monitor_log_.Mutable(index);
}
inline ::blink::MonitorDataInner* ReqAddMonitorLog::add_monitor_log() {
  return monitor_log_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::blink::MonitorDataInner >&
ReqAddMonitorLog::monitor_log() const {
  return monitor_log_;
}
inline ::google::protobuf::RepeatedPtrField< ::blink::MonitorDataInner >*
ReqAddMonitorLog::mutable_monitor_log() {
  return &monitor_log_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace blink

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::blink::MsgRetCode>() {
  return ::blink::MsgRetCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::blink::SCallType>() {
  return ::blink::SCallType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_blink_2eproto__INCLUDED
